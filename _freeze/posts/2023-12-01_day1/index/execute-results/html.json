{
  "hash": "06647dd26036051a33daaa1055d7ec25",
  "result": {
    "markdown": "---\ntitle: \"Day 1 - Calibration Numbers\"\ndate: 2023-12-01\ndate-modified: last-modified\n---\n\n\n## Part 1\n\n> On each line, the calibration value can be found by combining the *first digit* and the *last digit* (in that order) to form a single *two-digit number*.\n\nOk, I'll do this with `stringr`. Plan is to get all the digits, and then grab the first and the last one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(purrr)\nlibrary(tibble)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"input.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract_all(input, pattern = r\"(\\d)\") |> # <1> \n  map(                                       # <2>\n    ~c(.x[1], rev(.x)[1])                    # <2>\n  ) |>                                       # <2>\n  map_chr(                                   # <3>\n    ~str_c(.x, collapse = \"\")                # <3>\n  ) |>                                       # <3>\n  as.numeric() |>                            # <4>\n  sum()                                      # <5>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55607\n```\n:::\n:::\n\n\n1.  Extract all digits from each line. Returns a list of character vectors.\n2.  Use `map()` to grab the first and last digit. R doesn't have reverse indexing, so to get the last digit you need to reverse it and get the first value.\n3.  Paste the digits together with `str_c()` using `map_chr()` will auto simplify the output to a character vector.\n4.  Coersion to numeric.\n5.  Sum\n\n## Part 2\n\n> It looks like some of the digits are actually *spelled out with letters*: `one`, `two`, `three`, `four`, `five`, `six`, `seven`, `eight`, and `nine` *also* count as valid \"digits\".\n\nokay...\n\nI'll use a named vector for the conversion to numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum = 1:9\nnames(num) <- as.character(1:9)\nnum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4 5 6 7 8 9 \n1 2 3 4 5 6 7 8 9 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nchr = 1:9\nnames(chr) <- c(\"one\", \"two\",\n                \"three\", \"four\", \"five\",\n                \"six\", \"seven\", \"eight\",\n                \"nine\")\nchr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  one   two three  four  five   six seven eight  nine \n    1     2     3     4     5     6     7     8     9 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_chr <- c(num, chr)\nnum_chr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    1     2     3     4     5     6     7     8     9   one   two three  four \n    1     2     3     4     5     6     7     8     9     1     2     3     4 \n five   six seven eight  nine \n    5     6     7     8     9 \n```\n:::\n:::\n\n\nAnd now for my big ugly regex\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"\\\\d\", names(chr) ) |> \n  str_c(collapse = \"|\")->\n  pattern\npattern\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\\d|one|two|three|four|five|six|seven|eight|nine\"\n```\n:::\n:::\n\n\nLet's try it on the sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample <- (\"two1nine\neightwothree\nabcone2threexyz\nxtwone3four\n4nineeightseven2\nzoneight234\n7pqrstsixteen\") |> \n  str_split(\n    \"\\\\n\",\n  ) |> \n  unlist()\n```\n:::\n\n\n> In this example, the calibration values are `29`, `83`, `13`, `24`, `42`, `14`, and `76`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample |> \n  str_extract_all(pattern) |> \n  map(\n    ~c(.x[1], rev(.x)[1])\n  ) |> \n  map(\n    ~num_chr[.x]\n  ) |> \n  map_chr(\n    ~str_c(.x, collapse = \"\")\n  ) |> \n  as.numeric() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 29 83 13 24 42 14 76\n```\n:::\n:::\n\n\nGreat, let's try it on the real input!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  str_extract_all(pattern) |> \n  map(\n    ~c(.x[1], rev(.x)[1])\n  ) |> \n  map(\n    ~num_chr[.x]\n  ) |> \n  map_chr(\n    ~str_c(.x, collapse = \"\")\n  ) |> \n  as.numeric() |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55309\n```\n:::\n:::\n\n\n### Breaking it down\n\nLet's make sure we're getting all the right stuff.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  str_extract_all(pattern) |> \n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n\nOk, we're not losing any lines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  str_extract_all(pattern) |> \n  map_lgl(~length(.x) >= 2) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 936\n```\n:::\n:::\n\n\nokay... some lines aren't getting 2 digits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoo_short <- input |> \n  str_extract_all(pattern) |> \n  map_lgl(~length(.x) >= 2) \ninput[!too_short][1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"sqpxs1cgcrmctlgqvzxbcjzgr\" \"llbkdcpxkg1tnmnmrbskpdb\"  \n [3] \"gqlp7\"                     \"5qjlqp\"                   \n [5] \"9j\"                        \"sn6\"                      \n [7] \"4pfcfnfqftbfnxds\"          \"7mgk\"                     \n [9] \"tvmgkxbrtdv6mzcpkf\"        \"5mmrdtrzctqxggtzhplfnphgp\"\n```\n:::\n:::\n\n\nOk, these aren't the problem.\n\n### Overlapping numbers?\n\nOkay, maybe I need a special function to extract the digits one by one. I can't tell if overlapping digits should count or not. With `str_extract_all()`, it extracts `\"one\"` from the sample string, but *not* `eight`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"zoneight234\" |> \n  str_extract_all(pattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"one\" \"2\"   \"3\"   \"4\"  \n```\n:::\n:::\n\n\n### Overlapping extraction\n\nTo keep the order of digits, I think I need to use `str_locate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatterns <- names(num_chr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_digits <- function(str, lookup){\n  \n  patterns <- names(lookup)\n  \n  map(patterns, ~str_locate(str, .x)) |> \n    discard(~is.na(.x[1])) |> \n    map(as_tibble) |> \n    list_rbind() |> \n    arrange(start) |> \n    mutate(\n      digit_chr = str_sub(string = str, start = start, end = end),\n      digit_num = lookup[digit_chr]\n    ) ->\n    all_nums\n  \n  all_nums |> \n      slice(c(1, n())) |> \n      pull(digit_num) |> \n      str_c(collapse = \"\") |> \n      as.numeric()\n            \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  map(\n    ~get_digits(.x, num_chr)\n  ) |> \n  unlist() |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55224\n```\n:::\n:::\n\n\ndamn, this wasn't right either.\n\n### Modifying the string.\n\nGot an idea from [here](https://github.com/fuglede/adventofcode/blob/master/2023/day01/solutions.py).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplacements <- str_c(\n  names(chr), chr, names(chr)\n)\nnames(replacements) <- names(chr)\nreplacements\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          one           two         three          four          five \n    \"one1one\"     \"two2two\" \"three3three\"   \"four4four\"   \"five5five\" \n          six         seven         eight          nine \n    \"six6six\" \"seven7seven\" \"eight8eight\"   \"nine9nine\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreplace_name <- function(line, replacements){\n  for(r in names(replacements)){\n    line = str_replace_all(line, pattern = r, replacement = replacements[r])\n  }\n  return(line)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  map_chr(\n    ~replace_name(.x, replacements)\n  ) |> \n  str_extract_all(r\"(\\d)\") |> \n  map(\n    ~c(.x[1], rev(.x)[1])\n  ) |> \n  map_chr(\n    ~str_c(.x, collapse = \"\")\n  ) |> \n  as.numeric() |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55291\n```\n:::\n:::\n\n\nWell, that did it. Day 1 was already pretty ugly!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}