{
  "hash": "7f52a023eada3c4add958471161a3093",
  "result": {
    "markdown": "---\ntitle: \"Day 1 - Calibration Numbers\"\n---\n\n\n## Part 1\n\n> On each line, the calibration value can be found by combining the *first digit* and the *last digit* (in that order) to form a single *two-digit number*.\n\nOk, I'll do this with `stringr`. Plan is to get all the digits, and then grab the first and the last one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(purrr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"input.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract_all(input, pattern = r\"(\\d)\") |> # <1> \n  map(                                       # <2>\n    ~c(.x[1], rev(.x)[1])                    # <2>\n  ) |>                                       # <2>\n  map_chr(                                   # <3>\n    ~str_c(.x, collapse = \"\")                # <3>\n  ) |>                                       # <3>\n  as.numeric() |>                            # <4>\n  sum()                                      # <5>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55607\n```\n:::\n:::\n\n\n1.  Extract all digits from each line. Returns a list of character vectors.\n2.  Use `map()` to grab the first and last digit. R doesn't have reverse indexing, so to get the last digit you need to reverse it and get the first value.\n3.  Paste the digits together with `str_c()` using `map_chr()` will auto simplify the output to a character vector.\n4.  Coersion to numeric.\n5.  Sum\n\n## Part 2\n\n> It looks like some of the digits are actually *spelled out with letters*: `one`, `two`, `three`, `four`, `five`, `six`, `seven`, `eight`, and `nine` *also* count as valid \"digits\".\n\nokay...\n\nI'll use a named vector for the conversion to numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum = 1:9\nnames(num) <- as.character(1:9)\nnum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4 5 6 7 8 9 \n1 2 3 4 5 6 7 8 9 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nchr = 1:9\nnames(chr) <- c(\"one\", \"two\",\n                \"three\", \"four\", \"five\",\n                \"six\", \"seven\", \"eight\",\n                \"nine\")\nchr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  one   two three  four  five   six seven eight  nine \n    1     2     3     4     5     6     7     8     9 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_chr <- c(num, chr)\nnum_chr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    1     2     3     4     5     6     7     8     9   one   two three  four \n    1     2     3     4     5     6     7     8     9     1     2     3     4 \n five   six seven eight  nine \n    5     6     7     8     9 \n```\n:::\n:::\n\n\nAnd now for my big ugly regex\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"\\\\d\", names(chr) ) |> \n  str_c(collapse = \"|\")->\n  pattern\npattern\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\\d|one|two|three|four|five|six|seven|eight|nine\"\n```\n:::\n:::\n\n\nLet's try it on the sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample <- (\"two1nine\neightwothree\nabcone2threexyz\nxtwone3four\n4nineeightseven2\nzoneight234\n7pqrstsixteen\") |> \n  str_split(\n    \"\\\\n\",\n  ) |> \n  unlist()\n```\n:::\n\n\n> In this example, the calibration values are `29`, `83`, `13`, `24`, `42`, `14`, and `76`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample |> \n  str_extract_all(pattern) |> \n  map(\n    ~c(.x[1], rev(.x)[1])\n  ) |> \n  map(\n    ~num_chr[.x]\n  ) |> \n  map_chr(\n    ~str_c(.x, collapse = \"\")\n  ) |> \n  as.numeric() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 29 83 13 24 42 14 76\n```\n:::\n:::\n\n\nGreat, let's try it on the real input!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  str_extract_all(pattern) |> \n  map(\n    ~c(.x[1], rev(.x)[1])\n  ) |> \n  map(\n    ~num_chr[.x]\n  ) |> \n  map_chr(\n    ~str_c(.x, collapse = \"\")\n  ) |> \n  as.numeric() |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55309\n```\n:::\n:::\n\n\n### Breaking it down\n\nLet's make sure we're getting all the right stuff.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  str_extract_all(pattern) |> \n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n\nOk, we're not losing any lines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  str_extract_all(pattern) |> \n  map_lgl(~length(.x) >= 2) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 936\n```\n:::\n:::\n\n\nokay... some lines aren't getting 2 digits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoo_short <- input |> \n  str_extract_all(pattern) |> \n  map_lgl(~length(.x) >= 2) \ninput[!too_short][1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"sqpxs1cgcrmctlgqvzxbcjzgr\" \"llbkdcpxkg1tnmnmrbskpdb\"  \n [3] \"gqlp7\"                     \"5qjlqp\"                   \n [5] \"9j\"                        \"sn6\"                      \n [7] \"4pfcfnfqftbfnxds\"          \"7mgk\"                     \n [9] \"tvmgkxbrtdv6mzcpkf\"        \"5mmrdtrzctqxggtzhplfnphgp\"\n```\n:::\n:::\n\n\nOk, these aren't the problem.\n\n### Overlapping numbers?\n\nOkay, maybe I need a special function to extract the digits one by one. I can't tell if overlapping digits should count or not. With `str_extract_all()`, it extracts `\"one\"` from the sample string, but *not* `eight`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"zoneight234\" |> \n  str_extract_all(pattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"one\" \"2\"   \"3\"   \"4\"  \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}